# -*- coding: utf-8 -*-
"""A*.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mmTa9JN7F-RcbHg05ALRigtEABO-jQd0
"""

# IMPORTING NECESSARY LIBRARIES
import numpy as np
from math import dist
import matplotlib.pyplot as plt
import time
import heapq

# DEFINING A NODE CLASS TO STORE NODES AS OBJECTS  
class Node:

    def __init__(self, x, y, theta, cost, parent_id, c2g = 0):
        self.x = x
        self.y = y
        self.theta = theta
        self.cost = cost
        self.parent_id = parent_id
        self.c2g = c2g 
        
        
    def __lt__(self,other):
        return self.cost + self.c2g < other.cost + other.c2g


# DEFINING ACTIONS TO BE PERFORMED  
# CALCULATING COST TO COME FOR ALL ACTIONS  
def turn_60up(x,y,theta,step_size, cost):
    theta = theta + 60
    x = x + (step_size*np.cos(np.radians(theta)))
    y = y + (step_size*np.sin(np.radians(theta)))

    x = round(x)
    y = round(y)
    cost = 1 + cost
    return x,y,theta,cost

def turn_30up(x,y,theta, step_size, cost):
    theta = theta + 30
    x = x + (step_size*np.cos(np.radians(theta)))
    y = y + (step_size*np.sin(np.radians(theta)))

    x = round(x)
    y = round(y)
    cost = 1 + cost
    return x,y,theta, cost

def turn_0(x,y,theta, step_size, cost):
    theta = theta + 0
    x = x + (step_size*np.cos(np.radians(theta)))
    y = y + (step_size*np.sin(np.radians(theta)))

    x = round(x)
    y = round(y)
    cost = 1 + cost
    return x,y,theta, cost

def turn_30down(x,y,theta, step_size, cost):
    theta = theta - 30
    x = x + (step_size*np.cos(np.radians(theta)))
    y = y + (step_size*np.sin(np.radians(theta)))

    x = round(x)
    y = round(y)
    cost = 1 + cost
    return x,y,theta, cost

def turn_60down(x,y,theta, step_size, cost):
    theta = theta - 60
    x = x + (step_size*np.cos(np.radians(theta)))
    y = y + (step_size*np.sin(np.radians(theta)))

    x = round(x)
    y = round(y)
    cost = 1 + cost
    return x,y,theta,cost


# DEFINING A FUNCTION TO PERFORM ACTIONS THAT ARE DEFINED
def Action_set(move,x,y,theta,step_size,cost):

	if move == 0:
		return turn_60up(x,y,theta, step_size,cost)
	elif move == 1:
		return turn_30up(x,y,theta, step_size,cost)
	elif move == 2:
		return turn_0(x,y,theta,step_size,cost)
	elif move == 3:
		return turn_30down(x,y,theta,step_size,cost)
	elif move == 4:
		return turn_60down(x,y,theta,step_size,cost)
	else:
		return None


# CONFIGURATION SPACE CONSTRUCTION WITH OBSTACLES  
def obstacle_space(width, height, obstacle_clearence, robot_radius):
    
    # Generating Obstacle Space
    obstacle_space = np.full((height, width),0)
    
    for y in range(0, height) :
        for x in range(0, width):
            
            # Plotting Buffer Space for the Obstacles using Half Plane Equations
            
            # Rectangle 1 Obastacle
            r11_buffer = (x + ( obstacle_clearence + robot_radius)) - 100  
            r12_buffer = (y - ( obstacle_clearence + robot_radius)) - 100
            r13_buffer = (x - ( obstacle_clearence + robot_radius)) - 150
            
            
            # Rectangle 2 Obastacle
            r21_buffer = (x + ( obstacle_clearence + robot_radius)) - 100  
            r23_buffer = (x - ( obstacle_clearence + robot_radius)) - 150
            r24_buffer = (y + ( obstacle_clearence + robot_radius)) - 150 
            
            # Hexagon Obstacle
            h6_buffer = (y + ( obstacle_clearence + robot_radius)) +  0.58*(x + ( obstacle_clearence + robot_radius)) - 223.18
            h5_buffer = (y + ( obstacle_clearence + robot_radius)) - 0.58*(x - ( obstacle_clearence + robot_radius)) + 123.21
            h4_buffer = (x - ( obstacle_clearence + robot_radius)) - 364.95
            h3_buffer = (y - ( obstacle_clearence + robot_radius)) + 0.58*(x - ( obstacle_clearence + robot_radius)) - 373.21
            h2_buffer = (y - ( obstacle_clearence + robot_radius)) - 0.58*(x + ( obstacle_clearence + robot_radius)) - 26.82
            h1_buffer = (x + ( obstacle_clearence + robot_radius)) - 235.040
            
            # Triangle Obstacle
            t1_buffer = (x + ( obstacle_clearence + robot_radius)) - 460
            t2_buffer = (y - ( obstacle_clearence + robot_radius)) + 2*(x - ( obstacle_clearence + robot_radius)) - 1145
            t3_buffer = (y + ( obstacle_clearence + robot_radius)) - 2*(x - ( obstacle_clearence + robot_radius)) + 895
        
            # Setting the line constrain to obatain the obstacle space with buffer
            if((h6_buffer>0 and h5_buffer>0 and h4_buffer<0 and h3_buffer<0 and h2_buffer<0 and h1_buffer>0) or (r11_buffer>0 and r12_buffer<0 and r13_buffer<0) or (r21_buffer>0 and r23_buffer<0 and r24_buffer>0) or (t1_buffer>0 and t2_buffer<0 and t3_buffer>0)):
                obstacle_space[y, x] = 1
             
             
            # Plotting Actual Object Space Half Plane Equations
            
            # Rectangle 1 Obastacle
            r11 = (x) - 100  
            r12 = (y) - 100
            r13 = (x) - 150
            # r14 = y - 0
            
            # Rectangle 2 Obastacle
            r21 = (x) - 100  
            # r22 = (y) - 250
            r23 = (x) - 150
            r24 = (y) - 150 
            
            # Hexagon Obstacle
            h6 = (y) +  0.58*(x) - 223.18
            h5 = (y) - 0.58*(x) + 123.21
            h4 = (x) - 364.95
            h3 = (y) + 0.58*(x) - 373.21
            h2 = (y) - 0.58*(x) - 26.82
            h1 = (x) - 235.04  
            
            # Triangle Obstacle
            t1 = (x) - 460
            t2 = (y) + 2*(x) - 1145
            t3 = (y) - 2*(x) + 895

            # Setting the line constrain to obatain the obstacle space with buffer
            if((h6>0 and h5>0 and h4<0 and h3<0 and h2<0 and h1>0) or (r11>0 and r12<0 and r13<0 ) or (r21>0  and r23<0 and r24>0) or (t1>0 and t2<0 and t3>0)):
                obstacle_space[y, x] = 2    
                
       
    return obstacle_space


# TO SEE IF THE MOVE IS VALID OR NOT 
def ValidMove(x, y, obstacle_space):

	validmove = obstacle_space.shape

	if( x > validmove[1] or x < 0 or y > validmove[0] or y < 0 ):
		return False
	
	else:
		try:
			if(obstacle_space[y][x] == 1  or obstacle_space[y][x] == 2):
				return False
		except:
			pass
	return True


# DEFINING A FUNCTION TO CHECK IF THE PRESENT NODE IS GOAL NODE 
def Check_goal(present, goal):
    
    dt = dist((present.x, present.y), (goal.x, goal.y))             

    if dt < 1.5:
        return True
    else:
        return False

# GENERATE UNIQUE KEY  
def key(node):
    key_value = 222*node.x + 111*node.y 
    return key_value

#A function that defines the A start algorithm 
def Astar(start,goal,obstacle_space,step_size):                       

    if Check_goal(start, goal):
        return None
    goal_node = goal
    start_node = start
    
    moves = [0,1, 2, 3, 4]   
    open_list_nodes = {}  #List of all open nodes
    close_list_nodes = {} #List of all closed nodes
    priority_list = []  #List to store all dictionary entries with cost as the sorting variable    
    all_nodes = [] #stores all nodes that have been traversed, for visualization purposes.
    
    start_key = key(start_node) #Generating a unique key for identifying the node
    open_list_nodes[(start_key)] = start_node
    
    heapq.heappush(priority_list, [start_node.cost, start_node]) #This Data structure will prioritize the node to be explored which has less cost.
    
    while (len(priority_list) != 0):

        present_node = (heapq.heappop(priority_list))[1]
        all_nodes.append([present_node.x, present_node.y, present_node.theta])          
        present_id = key(present_node)
        if Check_goal(present_node, goal_node):
            goal_node.parent_id = present_node.parent_id
            goal_node.cost = present_node.cost
            print("Goal Node found")
            return all_nodes,1

        if present_id in close_list_nodes:  
            continue
        else:
            close_list_nodes[present_id] = present_node
		
        del open_list_nodes[present_id]

        for move in moves:
            x,y,theta,cost = Action_set(move,present_node.x,present_node.y,present_node.theta, step_size, present_node.cost)  
            
            c2g = dist((x, y), (goal.x, goal.y))  
   
            new_node = Node(x, y, theta, cost, present_node, c2g)   
   
            new_node_id = key(new_node) 
   
            if not ValidMove(new_node.x, new_node.y, obstacle_space):
                continue
            elif new_node_id in close_list_nodes:
                continue
   
            if new_node_id in open_list_nodes:
                if new_node.cost < open_list_nodes[new_node_id].cost: 
                    open_list_nodes[new_node_id].cost = new_node.cost
                    open_list_nodes[new_node_id].parent_id = new_node.parent_id
            else:
                open_list_nodes[new_node_id] = new_node
   			
            heapq.heappush(priority_list, [(new_node.cost + new_node.c2g), new_node]) 
   
    return  all_nodes,0


# BACKTRACK AND GENERATE SHORTEST PATH  
def Backtrack(goal_node):  
    x_path = []
    y_path = []
    x_path.append(goal_node.x)
    y_path.append(goal_node.y)

    parent_node = goal_node.parent_id
    while parent_node != -1:
        x_path.append(parent_node.x)
        y_path.append(parent_node.y)
        parent_node = parent_node.parent_id
        
    x_path.reverse()
    y_path.reverse()
    
    x = np.asarray(x_path)
    y = np.asanyarray(y_path)
    
    return x,y


#  PLOT OBSTACLES SPACE, EXPLORED NODES, SHORTEST PATH   
def plot(start_node,goal_node,x_path,y_path,all_nodes, obs_space):
    plt.figure()
    ### Start node and Goal node ###
    plt.plot(start_node.x, start_node.y, "Dw")
    plt.plot(goal_node.x, goal_node.y, "Dg")

    ### Configuration Space for Obstacles ####
    plt.imshow(obs_space, "GnBu")
    ax = plt.gca()
    ax.invert_yaxis() #y-axis inversion
    
    ### All visited nodes ###
    for i in range(len(all_nodes)):
        plt.plot(all_nodes[i][0], all_nodes[i][1], "2g-")
        plt.pause(0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001)

    ### Shortest path found ###
    plt.plot(x_path,y_path, ':r')
    plt.show()
    plt.pause(3)
    plt.close('all')



#Main function
if __name__ == '__main__':

    obstacle_clearence = 5 #mm
    
    # Radius of the Robot
    robot_radius = 5
    
    # Step Size of the Robot 
    robot_step_size = 3
    
    width = 600
    height = 250
    obstacle_space = obstacle_space(width, height, obstacle_clearence, robot_radius)
    c2g = 0
    
    #Start and Goal Coordinates from the User
    start_x = int(input("Enter the Start Position's X Coordinate: "))
    start_y = int(input("Enter the Start Position's Y Coordinate: "))
    start_theta = int(input("Enter the Start Orientation of the Robot: "))

    #Rounding off the 
    number = int(start_theta)
    remainder = number % 30
    if remainder < 15:
      start_theta = number - remainder
    else:
      start_theta = number + (30 - remainder)
    
    
    # Checking if the user input is valid 
    if not ValidMove(start_x, start_y, obstacle_space):
        print("Start node is out of bounds or in obstacle space")
        exit(-1)
        
		    
	# Taking Goal node coordinates as input from user   
    goal_x = int(input("Enter the Goal Position's X Coordinate: "))
    goal_y = int(input("Enter the Goal Position's Y Coordinate: "))
    goal_theta = int(input("Enter the Goal Orientation of the Robot: "))
    number = int(goal_theta)
    remainder = number % 30
    if remainder < 15:
      goal_theta = number - remainder
    else:
      goal_theta = number + (30 - remainder)
    
    
    # Checking if the user input is valid  
    if not ValidMove(goal_x, goal_y, obstacle_space):
        print("Goal node is out of bounds")
        exit(-1)
        

    # Timer to calculate computational  time  
    timer_start = time.time()
    
	# Creating start_node and goal_node objects 
    start_node = Node(start_x, start_y,start_theta, 0.0, -1,c2g)
    goal_node = Node(goal_x, goal_y,goal_theta, 0.0, -1, c2g)
    all_nodes,flag = Astar(start_node, goal_node, obstacle_space, robot_step_size)
    
    # Plot shortest path only when goal node is reached  
    if (flag)==1:
        x_path,y_path = Backtrack(goal_node)
        cost = goal_node.cost
        print("Total cost is:", cost)
        plot(start_node,goal_node,x_path,y_path, all_nodes,obstacle_space)
        timer_stop = time.time()
        C_time = timer_stop - timer_start
        print("The Total Runtime is:  ", C_time) 

    else:
        print("No path was found")